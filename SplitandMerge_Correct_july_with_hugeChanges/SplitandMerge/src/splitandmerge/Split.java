/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package splitandmerge;

import java.io.*;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.sql.Date;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.SecureRandom;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;



/**
 * 
 * @author chana911
 */
public class Split extends javax.swing.JFrame {

        private static final int IV_LENGTH=16;
    
        
//	String FileName = "Windows8-ConsumerPreview-64bit-English.iso";
	public static String S_Path1 = "C:/Users/chana/Desktop/test/Source";
	public static String Destination_path1 = "C:/Users/chana/Desktop/test/Split";
        public static String Despath;
        

//	String S_Complete = S_Path1 + "/" + FileName;
    
        static int Count =0;
        
	//String D_Complete = Destination_path1 + "/" + FileName;

	// int S_Size = 1024;

	/**
	 * Creates new form Split
	 */
	public Split() {
		initComponents();
              

	}

	

	static int split(String s, String s1, Integer ainteger[]) {
		int i = 0;
		char c = '\u0400';
		int j = 0;
		int k = 0;
		int l = 0;
		int i1 = 0;
		int j1 = 0;
		byte abyte0[] = new byte[c];
		FileInputStream fileinputstream = null;
		FileOutputStream fileoutputstream = null;
		Object obj = null;
		String s2 = "";
		long l1 = 0L;
		long l2 = System.currentTimeMillis();

		try {
			fileinputstream = new FileInputStream(s);
		} catch (Exception exception) {
			System.out.println("Error opening input file: " + exception);
			return 10;
		}

		try {
			while ((l = fileinputstream.read(abyte0)) > 0) {
				if (k++ == ainteger[i].intValue() || j == 0) {
					if (j > 0) {
						k = 1;
						try {
							fileoutputstream.close();
							if (i < ainteger.length - 1)
								i++;
						} catch (Exception exception1) {
							System.out.println("ex2: " + exception1);
						}
					}
					String s3 = s1 + createSuffix(++j);
					try {
						File file = new File(s3);
						fileoutputstream = new FileOutputStream(file);
					} catch (Exception exception4) {
						System.out.println("Error opening output file: "
								+ exception4);
						return 10;
					}
				}
				i1 += l;
				j1 += l;
				fileoutputstream.write(abyte0, 0, l);
			}
		} catch (Exception exception2) {
			System.out.println("ex1: " + exception2);
		}

		try {
			fileinputstream.close();
			fileoutputstream.close();
		} catch (Exception exception3) {
			System.out.println("ex4: " + exception3);
		}
		l1 = System.currentTimeMillis() - l2;
		System.out.println("Done!\n\n");
		System.out.println("bytes read: " + String.valueOf(i1)
				+ " \nbytes written: " + String.valueOf(j1) + "\n");
		System.out.println("parts created: " + j + "\n");
                Count=j;
		System.out.println("time used: " + String.valueOf(l1 / 1000L) + "."
				+ String.valueOf(l1 % 1000L) + " sec.\n");
		return 0;
	}

	static String createSuffix(int i) {
		String s;
		for (s = String.valueOf(i); s.length() < 3; s = "0" + s)
			;
		return "." + s;
	}

	/*
	 * public static int SplitValue(int size){
	 * 
	 * //int = txt_size.getText().; char c = '\u05A0'; Integer ainteger[];
	 * ainteger = new Integer[1]; ainteger[0] = new Integer(1048576);
	 * 
	 * 
	 * 
	 * return no;
	 * 
	 * 
	 * }
	 */

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        txt_browse = new javax.swing.JTextField();
        btn_Browse = new javax.swing.JButton();
        btn_Start = new javax.swing.JButton();
        btn_ViewDB = new javax.swing.JButton();
        btn_back = new javax.swing.JButton();
        txt_size = new javax.swing.JTextField();
        chkbox_encrypt = new javax.swing.JCheckBox();
        chkbox_Compress = new javax.swing.JCheckBox();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        btn_Browse.setText("Browse");
        btn_Browse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_BrowseActionPerformed(evt);
            }
        });

        btn_Start.setText("Start");
        btn_Start.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_StartActionPerformed(evt);
            }
        });

        btn_ViewDB.setText("ViewDB");

        btn_back.setText("Back");
        btn_back.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_backActionPerformed(evt);
            }
        });

        chkbox_encrypt.setText("Encrypt");

        chkbox_Compress.setText("Compress");

        jLabel1.setText("Encrypt");

        jLabel2.setText("Compress");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(32, 32, 32)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(txt_browse, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(38, 38, 38)
                        .addComponent(btn_Browse)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(txt_size)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(btn_Start)
                                .addGap(43, 43, 43)
                                .addComponent(btn_ViewDB)))
                        .addGap(29, 29, 29)
                        .addComponent(btn_back)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 125, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(47, 47, 47)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(chkbox_Compress)
                                .addContainerGap())
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(chkbox_encrypt)
                                .addGap(46, 46, 46))))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt_browse, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btn_Browse))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt_size, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(chkbox_encrypt)
                    .addComponent(jLabel1))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btn_Start)
                            .addComponent(btn_ViewDB)
                            .addComponent(btn_back)
                            .addComponent(chkbox_Compress)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jLabel2)))
                .addContainerGap(52, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

	private void btn_backActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_btn_backActionPerformed
		// TODO add your handling code here:
		new Main().setVisible(true);
		this.dispose();
	}// GEN-LAST:event_btn_backActionPerformed

	private void btn_BrowseActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_btn_BrowseActionPerformed
		
				

	}// GEN-LAST:event_btn_BrowseActionPerformed

	private void btn_StartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_StartActionPerformed
        
        try {                                          
        // TODO add your handling code here:
           
        //List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
//        DbConnect dbconnect = new DbConnect();
//        List<MyFile> listofrecords = dbconnect.selectFullQuery(1);
//        
//                for(MyFile file2 : listofrecords){
//                long num = file2.getId();
//                }
            
      
        char c = '\u05A0';
        Integer ainteger[];
        ainteger = new Integer[1];
        ainteger[0] = new Integer(1048576);
        
        DbConnect dbConnect = new DbConnect();
        
       
        List<MyFile> listOfFiles = Read(S_Path1);
       
        
        
//         try {
//            dbConnect.saveFiles(listOfFiles);
//            
////            List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
////            dbConnect.saveSPFiles(DlistOfFiles);
//            
//        } catch (SQLException ex) {
//            Logger.getLogger(Split.class.getName()).log(Level.SEVERE, null, ex);
//        }
        
        
      /*  
        for(MyFile file : listOfFiles ){

               split(S_Path1+"/"+file.getName(), Destination_path1+"/"+file.getName(), ainteger);
               dbConnect.saveFiles(file.getName(),file.getSize(),file.getHash(),file.getcDate());
               
                List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
                    for(MYSpFile file2: DlistOfFiles){  
                        dbConnect.saveSPFiles(file2.getFid(),file2.getName(),file2.getSize(),file2.getHash(),file2.getCloud(),file2.getRCloud());
              }
        }
        * 
        */
        
      for(MyFile file : listOfFiles ){
          
          if((chkbox_encrypt.isSelected())&&(chkbox_Compress.isSelected())){
              
               String fzip= file.getName()+".zip";
              // String fzip= tempFileName+".zip";         
               compressFile(S_Path1+"/"+file.getName());
          
            
                        String fileName = S_Path1+"/"+fzip;
			String tempFileName=fileName+".enc";
			String resultFileName=fileName+".dec";

			File Sfile = new File(fileName);
			if(!Sfile.exists()){
				System.out.println("No file "+fileName);
				return;
			}
			File Efile = new File(tempFileName);
			File Dfile = new File(resultFileName);
			if(Efile.exists() || Dfile.exists()){
				System.out.println("File for encrypted temp file or for the result decrypted file already exists. Please remove it or use a different file name");
				return;
			}

			copy(Cipher.ENCRYPT_MODE, fileName, tempFileName, "password12345678");
			//copy(Cipher.DECRYPT_MODE, tempFileName, resultFileName, "password12345678");

			System.out.println("Success. Find encrypted and decripted files in current directory");
                
              String fzipencrypt= file.getName()+".zip.enc";
              // String fzip= tempFileName+".zip";         
              // compressFile(tempFileName);
              Despath = CreateFolder(Destination_path1);
              // String zippath= S_Path1+"/"+fzip;
               long FSize = getFileSize(S_Path1+"/"+fzip);
               
                             
             //  split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               split(S_Path1+"/"+fzipencrypt, Despath+"/"+fzipencrypt, ainteger);
               dbConnect.saveFiles(fzipencrypt,file.getSize(),file.getHash(),file.getcDate());
              
          
          }
          else if(chkbox_encrypt.isSelected()){
              
                 String fzip= file.getName();
              // String fzip= tempFileName+".zip";         
             //  compressFile(S_Path1+"/"+file.getName());
          
            
                        String fileName = S_Path1+"/"+fzip;
			String tempFileName=fileName+".enc";
			String resultFileName=fileName+".dec";

			File Sfile = new File(fileName);
			if(!Sfile.exists()){
				System.out.println("No file "+fileName);
				return;
			}
			File Efile = new File(tempFileName);
			File Dfile = new File(resultFileName);
			if(Efile.exists() || Dfile.exists()){
				System.out.println("File for encrypted temp file or for the result decrypted file already exists. Please remove it or use a different file name");
				return;
			}

			copy(Cipher.ENCRYPT_MODE, fileName, tempFileName, "password12345678");
			//copy(Cipher.DECRYPT_MODE, tempFileName, resultFileName, "password12345678");

			System.out.println("Success. Find encrypted and decripted files in current directory");
                
              String fzipencrypt= file.getName()+".enc";
              // String fzip= tempFileName+".zip";         
              // compressFile(tempFileName);
              Despath = CreateFolder(Destination_path1);
              // String zippath= S_Path1+"/"+fzip;
               long FSize = getFileSize(S_Path1+"/"+fzip);
               
                             
             //  split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               split(S_Path1+"/"+fzipencrypt, Despath+"/"+fzipencrypt, ainteger);
               dbConnect.saveFiles(fzipencrypt,file.getSize(),file.getHash(),file.getcDate());
              
          }
          else if(chkbox_Compress.isSelected()){
              
               String fzip= file.getName()+".zip";
              // String fzip= tempFileName+".zip";         
               compressFile(S_Path1+"/"+file.getName());
          
            
                                    
              String fzipencrypt= file.getName()+".zip";
              Despath = CreateFolder(Destination_path1);
          
              long FSize = getFileSize(S_Path1+"/"+fzip);
               
                             
             //  split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               split(S_Path1+"/"+fzipencrypt, Despath+"/"+fzipencrypt, ainteger);
               dbConnect.saveFiles(fzipencrypt,file.getSize(),file.getHash(),file.getcDate());
              
          
          }
          else if(chkbox_encrypt.isSelected()){
              
                     String fzip= file.getName();
              // String fzip= tempFileName+".zip";         
              // compressFile(S_Path1+"/"+file.getName());
          
            
                        String fileName = S_Path1+"/"+fzip;
			String tempFileName=fileName+".enc";
			String resultFileName=fileName+".dec";

			File Sfile = new File(fileName);
			if(!Sfile.exists()){
				System.out.println("No file "+fileName);
				return;
			}
			File Efile = new File(tempFileName);
			File Dfile = new File(resultFileName);
			if(Efile.exists() || Dfile.exists()){
				System.out.println("File for encrypted temp file or for the result decrypted file already exists. Please remove it or use a different file name");
				return;
			}

			copy(Cipher.ENCRYPT_MODE, fileName, tempFileName, "password12345678");
			//copy(Cipher.DECRYPT_MODE, tempFileName, resultFileName, "password12345678");

			System.out.println("Success. Find encrypted and decripted files in current directory");
                
              String fzipencrypt= file.getName()+".enc";
              // String fzip= tempFileName+".zip";         
              // compressFile(tempFileName);
              Despath = CreateFolder(Destination_path1);
              // String zippath= S_Path1+"/"+fzip;
               long FSize = getFileSize(S_Path1+"/"+fzip);
               
                             
             //  split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               split(S_Path1+"/"+fzipencrypt, Despath+"/"+fzipencrypt, ainteger);
               dbConnect.saveFiles(fzipencrypt,file.getSize(),file.getHash(),file.getcDate());
          
          }
          else
          {
               String fzip= file.getName();
              
              Despath = CreateFolder(Destination_path1);
              // String zippath= S_Path1+"/"+fzip;
               long FSize = getFileSize(S_Path1+"/"+fzip);
               
                             
             //  split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               split(S_Path1+"/"+fzip, Despath+"/"+fzip, ainteger);
               dbConnect.saveFiles(fzip,file.getSize(),file.getHash(),file.getcDate());
              
          
          }
          
           
               
           
         
                 List<MYSpFile> DlistOfFiles = ReadSPFile(Despath);
                    for(MYSpFile file2: DlistOfFiles){  
                       dbConnect.saveSPFiles(file2.getFid(),file2.getName(),file2.getSize(),file2.getHash(),file2.getCloud(),file2.getRCloud());
                       dbConnect.saveQueueSPFiles(1,file2.getName(), Despath);
                       dbConnect.Delete(1,"aaa");
              }
        }  
        
        
        
      //  List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
      //  dbConnect.saveSPFiles(DlistOfFiles);
        
       // List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
       // dbConnect.saveSPFiles(DlistOfFiles);
        
//        try {
//            dbConnect.saveFiles(listOfFiles);
//            
////            List<MYSpFile> DlistOfFiles = ReadSPFile(Destination_path1);
////            dbConnect.saveSPFiles(DlistOfFiles);
//            
//        } catch (SQLException ex) {
//            Logger.getLogger(Split.class.getName()).log(Level.SEVERE, null, ex);
//        }

        } 
        catch (Exception ex) {
            Logger.getLogger(Split.class.getName()).log(Level.SEVERE, null, ex);
        }

    }//GEN-LAST:event_btn_StartActionPerformed


	
	public static String getHash(String Scomplete_path)
			throws Exception {

		String HValue;
		MessageDigest md = MessageDigest.getInstance("MD5");
		FileInputStream fis = new FileInputStream(Scomplete_path);

		byte[] dataBytes = new byte[1024];

		int nread = 0;
		try {
			while ((nread = fis.read(dataBytes)) != -1) {
				md.update(dataBytes, 0, nread);
			}
		} catch (IOException ex) {
			Logger.getLogger(Split.class.getName()).log(Level.SEVERE, null, ex);
		};
                
		byte[] mdbytes = md.digest();

		// convert the byte to hex format method 1
		StringBuffer sb = new StringBuffer();
		for (int i = 0; i < mdbytes.length; i++) {
			sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16)
					.substring(1));
		}

		System.out.println("Digest(in hex format):: " + sb.toString());

		HValue = sb.toString();
		return HValue;

	}

	/*
	 * private void saveFile(List<Map<String,String>> fileList) { try {
	 * 
	 * String[] sqls = new String[fileList.size()]; int i = 0; for(Map aa :
	 * fileList) { Entry e = (Entry)aa.entrySet(); // String sql =
	 * "insert into Full_File(Fname,FSize,HashValue,Up_date) values('"
	 * +e.getKey()+"' ,'"+e.getValue()+""'); // sqls[i] = sql;
	 * 
	 * i++; } // TODO add your handling code here: Connection conn =
	 * Conn.getConnection(); Statement s = conn.createStatement();
	 * 
	 * 
	 * 
	 * // s.executeUpdate(
	 * " insert into insurance(insno,ins_com_name,vehicle_no) values ('" +
	 * insno.getText() + "' , '" + inscom.getText() + "' , '" +
	 * vhno.getSelectedItem() + "')"); // JOptionPane.showMessageDialog(null,
	 * "Record inserted"); // clear(); } catch (Exception ex) { //
	 * Logger.getLogger(insurance.class.getName()).log(Level.SEVERE, null, ex);
	 * ex.printStackTrace(); JOptionPane.showMessageDialog(null,
	 * "Record  inserte failed"); } }
	 */

	/*
	 * public String getHash(File file){
	 * 
	 * return null; }
	 */

	public static List<MyFile> Read(String path) throws Exception{
		// int Count =0;
		// String Fname ;
                String Full_Path;
                String Hash,date;
		File folder = new File(path);
		List<MyFile> fileList = new ArrayList<MyFile>();
		for(File sysFile :  folder.listFiles()) {
                    Full_Path = path + "/" + sysFile.getName();
                    long S = getFileSize(Full_Path);
                 //   Hash = getHash(Full_Path);
                    Calendar cal = Calendar.getInstance();
                    date = cal.getTime().toString();
                    
			MyFile myFile = new MyFile();
			myFile.setName(sysFile.getName());
                  //  	myFile.setHash(Hash);
			myFile.setcDate(date);
			myFile.setSize(S);
			myFile.setFile(sysFile);
                        fileList.add(myFile);
		}
		
		return fileList;
	}
        
        public static List<MYSpFile> ReadSPFile(String path) throws Exception{
		int NoPackets;
                int k=0;
                int j=0;
                int m=0;
                
             
                NoPackets=Count;
                int[] raidArray1 = new int[2*NoPackets];
                String Full_Path;
                String Hash,date;
                String Fname;
     
                DbConnect dbconnect = new DbConnect();
		File folder = new File(path);
		List<MYSpFile> fileList = new ArrayList<MYSpFile>();
          //      List<MyFile> listofrecords = dbconnect.selectFullQuery(fid);
                
        for(int i=0; i<NoPackets;i++){  
               
            k =(int)dbconnect.RowCount();
             //  dbconnect. 
               List<MyFile> listofrecords = dbconnect.selectFullQuery(k);
              
               for(File sysFile :  folder.listFiles()) {
                   
                   
                   for(MyFile file2 : listofrecords){
                    
                   
                    Full_Path = path + "/" + sysFile.getName();
                    
                   // Fname = sysFile.getName().replace(".00"+ ++j, "");
                    Fname = sysFile.getName().replace(createSuffix(++j),"");
                    
                    if(file2.getName().equalsIgnoreCase(Fname)){
                                     
                  //    Hash = getHash(Full_Path);  
                      long S = getFileSize(Full_Path);
                      Calendar cal = Calendar.getInstance();
                      date = cal.getTime().toString();
                      i++;
                      raidArray1 = raid(NoPackets, 2, 1, 1);
                      
                        MYSpFile mySPFile = new MYSpFile();
                        mySPFile.setFid(file2.getId());
                        mySPFile.setName(sysFile.getName());
                    //    mySPFile.setHash(Hash);
                        mySPFile.setcDate(date);
                        mySPFile.setSize(S);
                        mySPFile.setFile(sysFile);
                        mySPFile.setCloud(raidArray1[m]);
                        mySPFile.setRcloud(raidArray1[m+1]);
                        fileList.add(mySPFile);
                        m=m+2;
                      
                        }
                         else{
                           j=0;
                        }
                     
                     }
                   
                } 
           }
                
          return fileList;
	}

	
        public static long getFileSize(String filename) {

		File file = new File(filename);

		if (!file.exists() || !file.isFile()) {
			System.out.println("File doesn\'t exist");
			return -1;
		}

		// Here we get the actual size
		return file.length();
        }
        
  public static int[] raid(int pNumber, int c1, int c2, int c3) {

        int numberOfClouds = 3;
        int[] raidArray = new int[2 * pNumber];
        int count1 = (c1 * 2) / 1024;
        int count2 = (c2 * 2) / 1024;
        int count3 = (c3 * 2) / 1024;
        int i = 0;

       // backplogger.info("Raid starting with cloud bandwidths : " + count1 + ", " + count2 + ", " + count3 + " number of packets " + 2 * pNumber);
        do {
            int o = getRandomCloud(numberOfClouds);
            int r = getRandomCloud(numberOfClouds);

            while (o == r) {
                r = getRandomCloud(numberOfClouds);
            }
            raidArray[i] = o;
            raidArray[i + 1] = r;
            i = i + 2;

            if (o == 1 && r == 2) {
                count1 = count1 - 1;
                count2 = count2 - 1;
            } else if (o == 1 && r == 3) {
                count1 = count1 - 1;
                count3 = count3 - 1;
            } else if (o == 2 && r == 1) {
                count2 = count2 - 1;
                count1 = count1 - 1;
            } else if (o == 2 && r == 3) {
                count2 = count2 - 1;
                count3 = count3 - 1;
            } else if (o == 3 && r == 1) {
                count3 = count3 - 1;
                count1 = count1 - 1;
            } else if (o == 3 && r == 2) {
                count3 = count3 - 1;
                count2 = count2 - 1;
            }
        }
        while ((count1 + count2 + count3) / 2 > 0);
        //backplogger.info("Raid array completed successfully.");
        return raidArray;
    }

  private static int getRandomCloud(int numberOfClouds) {

        return (int) ((Math.random() * 10) % numberOfClouds) + 1;
    }

  public static void compressFile(String path){
    
  String D_path  =path+ ".zip";

  try
  {
            try (ZipOutputStream out = new ZipOutputStream(new 
                 BufferedOutputStream(new FileOutputStream(D_path)))) {
                byte[] data = new byte[1000]; 
                BufferedInputStream in = new BufferedInputStream(new FileInputStream(path));
                int count;
                out.putNextEntry(new ZipEntry("outFile.zip"));
               while((count = in.read(data,0,1000)) != -1)
               {  
               out.write(data, 0, count);
               }
               in.close();
               out.flush();
            }
  System.out.println("Your file is zipped");
 }
 catch(Exception e)
  {
 e.printStackTrace();
  }  
    
 }
  
  public static String CreateFolder(String path)throws Exception{
  
        String fldate;
               
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd-HHmmss");
        java.util.Date date = new java.util.Date();
        fldate = dateFormat.format(date);

        String strDirectoy =path+ "/" +fldate;
 
        // Create one directory
        boolean success = (
        new File(strDirectoy)).mkdir();
        if (success) {
        System.out.println("Directory: " + strDirectoy + " created");
        } 
   
//    catch (Exception e){//Catch exception if any
//       System.err.println("Error: " + e.getMessage());
//    }
    
      return strDirectoy;
  }
  
  public static void copy(int mode, String inputFile, String outputFile, String password) throws Exception {

		BufferedInputStream is = new BufferedInputStream(new FileInputStream(inputFile));
		BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(outputFile));
		if(mode==Cipher.ENCRYPT_MODE){
			encrypt(is, os, password);
		}
		else if(mode==Cipher.DECRYPT_MODE){
			//decrypt(is, os, password);
		}
		else throw new Exception("unknown mode");
		is.close();
		os.close();
	}
  
  public static void encrypt(InputStream in, OutputStream out, String password) throws Exception{

		SecureRandom r = new SecureRandom();
		byte[] iv = new byte[IV_LENGTH];
		r.nextBytes(iv);
		out.write(iv); //write IV as a prefix
		out.flush();
		//System.out.println(">>>>>>>>written"+Arrays.toString(iv));

		Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding"); //"DES/ECB/PKCS5Padding";"AES/CBC/PKCS5Padding"
		SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(), "AES");
		IvParameterSpec ivSpec = new IvParameterSpec(iv);
		cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);    	

		out = new CipherOutputStream(out, cipher);
		byte[] buf = new byte[1024];
		int numRead = 0;
		while ((numRead = in.read(buf)) >= 0) {
			out.write(buf, 0, numRead);
		}
		out.close();
	}
  
  
  
        

        
        

	/*
	 * for (int i = 0; i < listOfFiles.length; i++) {
	 * 
	 * /*if (listOfFiles[i].isFile()) { String files = listOfFiles[i].getName();
	 * Count++;
	 * 
	 * System.out.println(files);
	 * 
	 * }
	 * 
	 * }
	 * 
	 * 
	 * 
	 * 
	 * }
	 * 
	 * /**
	 * 
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		/*
		 * Set the Nimbus look and feel
		 */
		// <editor-fold defaultstate="collapsed"
		// desc=" Look and feel setting code (optional) ">
		/*
		 * If Nimbus (introduced in Java SE 6) is not available, stay with the
		 * default look and feel. For details see
		 * http://download.oracle.com/javase
		 * /tutorial/uiswing/lookandfeel/plaf.html
		 */
		try {
			for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager
					.getInstalledLookAndFeels()) {
				if ("Nimbus".equals(info.getName())) {
					javax.swing.UIManager.setLookAndFeel(info.getClassName());
					break;
				}
			}
		} catch (ClassNotFoundException ex) {
			java.util.logging.Logger.getLogger(Split.class.getName()).log(
					java.util.logging.Level.SEVERE, null, ex);
		} catch (InstantiationException ex) {
			java.util.logging.Logger.getLogger(Split.class.getName()).log(
					java.util.logging.Level.SEVERE, null, ex);
		} catch (IllegalAccessException ex) {
			java.util.logging.Logger.getLogger(Split.class.getName()).log(
					java.util.logging.Level.SEVERE, null, ex);
		} catch (javax.swing.UnsupportedLookAndFeelException ex) {
			java.util.logging.Logger.getLogger(Split.class.getName()).log(
					java.util.logging.Level.SEVERE, null, ex);
		}
		// </editor-fold>

		/*
		 * Create and display the form
		 */
		java.awt.EventQueue.invokeLater(new Runnable() {

			public void run() {
				new Split().setVisible(true);
			}
		});
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btn_Browse;
    private javax.swing.JButton btn_Start;
    private javax.swing.JButton btn_ViewDB;
    private javax.swing.JButton btn_back;
    private javax.swing.JCheckBox chkbox_Compress;
    private javax.swing.JCheckBox chkbox_encrypt;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JTextField txt_browse;
    private javax.swing.JTextField txt_size;
    // End of variables declaration//GEN-END:variables
}
